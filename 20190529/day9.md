# 20190529
继续坚持

## day 9

### 装饰器
属性命名以单下划线开头暗示属性受保护
用@property包装器包装setter和getter方法

- 单下划线开头仅仅是暗示作用，访问的时候在属性前加单下划线同样可以访问修改，不同于双下划线
- 一旦加了访问器，那么不加单下划线就不能修改AttributeError: can't set attribute
- 再加上修改器，就可以访问并修改了

### __slot__魔法
动态语言允许在程序运行期间给对象绑定新的属性或方法
也可以对已绑定的属性和方法进行解绑定

可以通过__slot__限定自定义类型的对象只能绑定某些属性
此限定只对当前类的对象有效，对子类并不起任何作用

### 静态方法和类方法
#### 静态方法
所谓静态方法主要是在对象创建出来前调用的方法。比如通过三角形类创建三角形对象前，先要检查三条边是否能构成三角形
```Python
 @staticmethod
    def is_valid(a, b, c):
        return (a + b > c) and (a + c > b) and (b + c > a)
```
定义静态函数时，也不需要参数self

#### 类方法
类方法的第一个参数约定名为cls
它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），
通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象
比如时钟，可以通过这个类方法获取当前时间并创建类对象

### 类之间的关系
类与类之间的关系有三种：is-a、has-a和use-a关系
- is-a关系也称为继承或泛化，比如学生与人的关系，手机和电子产品的关系
- has-a关系通常称为关联，比如部门和员工的关系，汽车和引擎的关系；如果是整体和部分的关联，就是聚合关系；
如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。
- use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。

### 继承与多态
子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）

### 抽象类
我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）
```Python
class Pet(object, metaclass=ABCMeta):
    """宠物
    存在抽象方法make_voice()不能实例化
    """

    def __init__(self, nickname):
        self._nickname = nickname

    @abstractmethod
    def make_voice(self):
        """发出声音"""
        pass
```